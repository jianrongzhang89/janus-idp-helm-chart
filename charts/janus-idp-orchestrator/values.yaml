# includeCustomResources set to true to have the custom resources (KnativeEventing, KnativeServing, SonataFlow and SonataFlowPlatform).
includeCustomResources: false

sonataFlowOperator:
  # enabled indicates whether the operator should be deployed by the chart
  enabled: true
  subscription:
    # namespace is the namespace where the operator should be deployed
    namespace: openshift-operators
    # channel is the channel of an operator package to subscribe to
    channel: alpha
    # installPlanApproval indicates whether the update should be installed automatically
    installPlanApproval: Automatic
    # pkgName is the name of the operator package
    pkgName: sonataflow-operator
    # sourceImage indicates the catalog image of the development build. Unset it for the release build.
    sourceImage: quay.io/jianrzha/kogito-serverless-operator-catalog:v2.0.0
    # source is the name of the catalog source for the operator
    source: sonataflow-operator

serverlessOperator:
# enabled indicates whether the operator should be deployed by the chart
  enabled: true
  subscription:
    # namespace is the namespace where the operator should be deployed
    namespace: openshift-serverless
    # channel is the channel of an operator package to subscribe to
    channel: stable
    # installPlanApproval indicates whether the update should be installed automatically
    installPlanApproval: Automatic
    # pkgName is the name of the operator package
    pkgName: serverless-operator

postgres:
  # externalPostgresDBHost is host name of an existing Postgres DB used by dataindex and job service. If empty, a local Postgres DB is deployed
  externalPostgresDBHost: ""
  # existingSecret is the name of existing secret to use for PostgreSQL credentials. `auth.postgresPassword`, `auth.password`, and `auth.replicationPassword` will be ignored and picked up from this secret. The secret might also contains the key `ldap-password` if LDAP is enabled. `ldap.bind_password` will be ignored and picked from this secret in this case.
  existingSecret: ""
  secretKeys:
    # userPasswordKey is the name of key in existing secret to use for PostgreSQL credentials. Only used when `auth.existingSecret` is set.
    userPasswordKey: password
  # database is the database instance used by dataindex and job service
  database: sonataflow
  # username is the database user name 
  username: postgres
  # password is the database password. Ignored if existingSecret is set.
  password: postgres
  # storage is the database storage size
  storage: 2Gi
  # port is the service port to access the database
  port: 5432
  # dataDir is the folder where the database data files are stored inside the container
  dataDir: /var/lib/postgresql/data/dbfiles

# override Janus image with one with the orchestrator plugin
backstage: 
  upstream:
    backstage:
      image:
        repository: rgolangh/orchestrator
      appConfig:
        orchestrator:
          catalog:
            environment: development
          sonataFlowService:
            # make this conditional devmode || sonataflow-operator
            baseUrl: http://devmode.{{ .Release.Namespace }}.svc.cluster.local
            port: 80
            path: /
            workflowsSource:
              localPath: /tmp
              gitRepositoryUrl: https://github.com/tiagodolphine/backstage-orchestrator-work

orchestrator:
  # namespace is the namespace where the data index, job service and workflows are deployed
  namespace: sonataflow-infra
  dataindex:
    # name is the service name of the data index
    name: data-index-service
    # port is the service port of the data index
    port: 8080
  jobsservice:
    # name is the service name of the job service
    name: jobs-service-service
    # port is the service port of the job service
    port: 8080
  sonataPlatform:
    resources:
      requests:
        memory: "64Mi"
        cpu: "250m"
      limits:
        memory: "1Gi"
        cpu: "500m"
  sonataflows:
  - name: event-timeout
    description: Event timeout example on k8s!
    version: 0.0.1
    profile: prod
    serviceTargetPort: 8080
    # propsConfigData if set, it overrides the default configmap generated by the operator for the workflow
    propsConfigData: |
      application.properties: |
        # Data Index configuration
        mp.messaging.outgoing.kogito-processinstances-events.url=http://data-index-service/processes
        mp.messaging.outgoing.kogito-usertaskinstances-events.url=http://data-index-service/tasks
        mp.messaging.outgoing.kogito-variables-events.url=http://data-index-service/variables
        # Skip user tasks and variables events sending.
        kogito.events.usertasks.enabled=false
        kogito.events.variables.enabled=false
        quarkus.log.category."io.smallrye.reactive.messaging".level = DEBUG
        quarkus.log.category."org.kie".level = DEBUG
        quarkus.log.category."io.quarkus.reactivemessaging".level = DEBUG
        quarkus.log.category."io.vertx".level = DEBUG
    spec: |+
      flow:
        start: PrintStartMessage
        events:
          - name: event1
            source: ''
            type: event1_event_type
          - name: event2
            source: ''
            type: event2_event_type
        functions:
          - name: systemOut
            type: custom
            operation: sysout
        timeouts:
          eventTimeout: PT60S
        states:
          - name: PrintStartMessage
            type: operation
            actions:
              - name: printSystemOut
                functionRef:
                  refName: systemOut
                  arguments:
                    message: "${\"event-state-timeouts: \" + $WORKFLOW.instanceId + \" has started.\"}"
            transition: WaitForEvent1
          - name: WaitForEvent1
            type: event
            onEvents:
              - eventRefs: [ event1 ]
                eventDataFilter:
                  data: "${ \"The event1 was received.\" }"
                  toStateData: "${ .exitMessage1 }"
                actions:
                  - name: printAfterEvent1
                    functionRef:
                      refName: systemOut
                      arguments:
                        message: "${\"event-state-timeouts: \" + $WORKFLOW.instanceId + \" executing actions for event1.\"}"

            transition: WaitForEvent2
          - name: WaitForEvent2
            type: event
            onEvents:
              - eventRefs: [ event2 ]
                eventDataFilter:
                  data: "${ \"The event2 was received.\" }"
                  toStateData: "${ .exitMessage2 }"
                actions:
                  - name: printAfterEvent2
                    functionRef:
                      refName: systemOut
                      arguments:
                        message: "${\"event-state-timeouts: \" + $WORKFLOW.instanceId + \" executing actions for event2.\"}"
            transition: PrintExitMessage
          - name: PrintExitMessage
            type: operation
            actions:
              - name: printSystemOut
                functionRef:
                  refName: systemOut
                  arguments:
                    message: "${\"event-state-timeouts: \" + $WORKFLOW.instanceId + \" has finalized. \" + if .exitMessage1 != null then .exitMessage1 else \"The event state did not receive event1, and the timeout has overdue\" end + \" -- \" + if .exitMessage2 != null then .exitMessage2 else \"The event state did not receive event2, and the timeout has overdue\" end }"
            end: true